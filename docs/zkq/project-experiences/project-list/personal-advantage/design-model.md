---
title: 设计模式（单例模式，代理模式，工厂模式，建造者模式，外观模式等 ）
category: 设计模式
tag:
  - 设计模式
---

## 面向对象的六大原则

面向对象的六大原则要求我们构建一个可扩展、高内聚、低耦合的程序，从而在不破坏已有代码稳定性的前提下满足需求的变化，即时版本不断迭代更新，系统架构仍然清晰、灵活、稳定。

### 单一职责原则（优化代码的第一步）

`Single Responsibility Principle`， 缩写`SRP`

**定义：**
```
就一个类而言，应该仅有一个引起它变化的原因。
即：一个类中封装的 函数 和 数据 应该具有很高的相关性
  也就是说，一个类 应该仅具有 一个功能。
  不同的功能封装在不同的类中，保证功能的独立性，降低代码的耦合程度。
```

**注意：** 

如何划分一个类、一个函数的职责，视具体的业务逻辑而定。但是应该基本保证：两个完全不一样的功能就应该封装在两个不同的类中。

### 开闭原则（让程序更稳定、更灵活）

`Open Close Principle`，缩写`OCP`

**定义：**
```
软件中的对象（类、模块、函数等）应该：
  对于扩展是开放的；
  对于修改是封闭的。
即：在程序的升级、维护过程中，对代码进行修改时，尽量采用扩展的方式来编写新的代码；避免对已有的代码进行修改。
这样做的目的是：避免将新编写的代码中的错误 引入到 已测试过的旧代码中，破坏原有的系统功能。
```

**具体要求：**

1. 程序一旦开发完成之后，除非已有的类中存在错误，否则不应该对其进行修改；

2. 程序后续升级、维护过程中新增的需求变化，应该已继承的方式，在新建的子类中 通过重写父类方法实现；

3. 为了使代码满足开闭原则，在接口中声明需要用到的功能函数，业务类中持有接口类型的引用，且业务类对外提供setter方法接受具体的实现类。
   >从而在不改动业务类内部代码的条件下，通过业务类提供的setter方法使得业务类内部的接口引用 指向不同的实现类对象，于是，业务类调用接口方法时，交给不同的实现类处理，这样就达到了在不修改业务类代码的基础上，修改业务类的功能实现。并且对于以后的升级、维护过程中，通过扩展创建不同的接口实现类 即可。


**注意：**

1. 遵循开闭原则，就是提高程序的可扩展性。**可扩展性是框架的最重要特性之一**。

2. 开闭原则要求我们尽量不修改已有代码，但是，当已有代码对 框架的可扩展性产生负面影响，或者存在其他的框架设计上的缺点时，应该尽早地对已有代码进行重构，避免继承已有的问题代码，从而导致继承子类的膨胀以及历史遗留代码的冗余。

### 里氏替换原则（构建扩展性更好的系统）

`Liskov Substitution Principle`，缩写`LSP`

**定义：**
```
所有引用过基类的地方必须能透明地使用其子类的对象。

即：对于以类型Base定义的程序Func，当把程序Func中的类型Base的对象base全部替换成类型
Sub的对象sub时，程序Func的行为没有发生变化，那么类型Sub是类型Base的子类型

也就是说，里氏替换原则就是依赖 继承和多态 去实现抽象
```

> 开闭原则和里氏替换原则 往往是生死相依、不离不弃的，开闭原则中对扩展开放的要求就是通过里氏替换原则来实现的。
>
> 开闭原则和里氏替换原则都强调了面向对象的重要特性 —— 抽象。从中可以看出**运用抽象是走向代码优化的重要一步**。

**注意：**
```
对于里氏替换原则所依赖的继承， 
虽然继承能够：（继承的优点）
    1. 提高代码的可扩展性；
    2. 重用代码，使子类拥有父类的方法和属性。
但是：（继承的缺点）
    1. 继承是具有入侵性的，即父类的方法和属性会被后创建的子类入侵拥有；
    2. 由于子类必须拥有父类的方法和属性，因此，使用继承可能会造成子类代码的冗余，灵活性降低。
因此，虽然 里氏替换原则+开闭原则 能够帮助我们构建扩展性更好的程序，
但是也应该视具体情况来权衡由于继承的优缺点所带来的利弊关系。
```

### 依赖倒置原则（让项目拥有变化的能力）

`Dependence Inversion Principle`，缩写`DIP`

**什么是依赖关系？**

如果一个类的改动会导致另一个类的改动，则称这两个类之间存在依赖关系。
通常依赖是单向的，当数据表现和数据模型分开设计时，数据表现依赖于数据模型（数据模型被数据表现依赖）。 
依赖关系使用带箭头的虚线表示，箭头指向被依赖的实体（数据模型）

**依赖倒置原则的定义：**
```
依赖者 不应该依赖 被依赖者的具体实现；而是应该依赖 被依赖者的抽象。

依赖倒置原则的目的是为了实现 类与类之间的解耦，这就要求我们面向抽象编程（亦或者称为 面向接口编程）

所谓的依赖倒置，不是依赖关系倒置了，而是 被依赖者 倒置了，即：从原来的 依赖具体实现 倒置成 依赖抽象。
```

**依赖倒置原则的关键点：**
```
1. 业务类之间的依赖关系通过抽象实现；（抽象不变，业务代码不变）
2. 抽象不依赖细节；（即细节变，抽象不变，从而在业务代码不变的条件下，改变业务的具体功能）
3. 细节依赖抽象。（即抽象变，细节变）
```

**注意：**

1. 依赖倒置原则要求我们面向接口编程，通过**依赖抽象**提高代码的可扩展性；

2. 开闭原则要求对扩展开放，对已有类的修改关闭，这就需要按照依赖倒置原则的要求，让已有类去依赖抽象，而依赖抽象之后，则需要我们按照里氏替换原则的要求，在引用抽象的地方必须能够透明地使用具体子类。即：
   > 里氏替换原则 对 依赖倒置原则 提出了要求：依赖抽象的地方必须能透明地依赖抽象的具体实现；
   >
   > 依赖倒置原则 保证了 开闭原则的可行性，即通过依赖抽象去实现扩展，避免修改已有类。

综上，开闭原则、里氏替换原则、依赖倒置原则的实现都离不开抽象，由此再次证明了之前所说的：运用抽象是走向代码优化的重要一步。

### 接口隔离原则（系统有更高的灵活性）

`InterfaceSegregation Principles`，缩写`ISP`

**定义：**
```
类间的依赖关系应该建立在最小的接口上，即接口中不应该存在不需要依赖的方法。

接口隔离原则 对 依赖倒置原则 提出了要求，即：
  要求 所依赖的接口中不能声明 不需要的依赖方法，避免依赖接口的臃肿。
```
    

    

### 迪米特原则（更好的可扩展性）

`Law of Demeter`，缩写`LOD`

也称为最少知识原则（`Least Knowledge Principle`）

**定义：**
```
Only talk to your immedate friends，即：只与直接的朋友通信。
  其中，直接的朋友关系 就是指 两个类之间的直接耦合关系，如组合、聚合、依赖关系等。
        
以依赖关系为例，迪米特原则要求 依赖者只能与被依赖者通信，即依赖者只能调用被依赖者提供的方法，
而被依赖者的内部实现不能让依赖者知道，也就是说 依赖者 不能访问并依赖到 被依赖者的内部实现，
比如： 
  如果类A 依赖 类B，类B的内部实现依赖类C；
  那么 类A 不能通过 类B提供的方法去访问并依赖类C，进而在类A中与类C进行通信。
  类A 与 类B 是直接朋友关系，类A 和 类C 是间接的朋友关系，
  迪米特原则要求 类A 只能与 类B进行通信，不能与类C进行通信。否则 类B的功能就会被弱化，
  并且导致 类A 不但与类B存在耦合关系，同时又与类C存在了耦合关系，从而导致出现纠缠不清的关系。
```

**注意：**
1. 依赖倒置原则要求与 具体实现 解耦。

2. 迪米特原则要求与 间接依赖 解耦。

## `SOLID`原则（面向对象编程的5个基本原则）

```
单一职责原则、开闭原则、里氏替换原则、接口隔离原则、依赖倒置原则，
这5个原则 被定义为 SOLID原则，作为面向对象编程的5个基本原则。

可以发现这 5大原则 最终可以总结为如下几个关键字：
  1. 单一职责；（单一职责原则）
  2. 抽象；    （开闭原则、里氏替换原则、依赖倒置原则）
  3. 最小化。  （接口隔离原则）
```

